#技巧型设计模式
[TOC]
##链模式
```
//jquery选择器
var A = function(selector){
    return new A.fn.init(selector);
}
A.fn = A.prototype = {
    constructor: A,
    init : function(selector, context){
        this.length = 0;
        context = context || document;
        if(!selectot.indexOf('#')){
            this.length = 1;
            this[0] = document.getElementById(selector.slice(1));
        }else{
            var eles = context.getElementsByTagName(selector.slice(1));
            this.length = ele.length
            for(var i =0;i<this.length;i++){
                this[i]=eles[i];
            }
            this.length = ele.
        }
        this.context = context;
        this.selector = selector;
        return this;
    },
    length: 2,
    size :function(){
        return this.length;
    },
    push: [].push,
    sort: [].sort,
    splice: [].splice
}
A.fn.init.prototype = A.fn;
//extend方法拓展
A.extend = A.fn.extend = function(){
    var i = 1,
        len = arguments.length,
        target = arguments[0],
        j;
    if(i == len){
        target = this;
        i--;
    }
    for(;i<len;i++){
        for(var j in arguments[i]){
            target[j] = arguments[j];
        }
    }
    return target;
}
```

##委托模式
每个子元素都绑定相同事件时，可以把事件委托给父元素;还可以处理未来新生成的元素
```
ul.onclick = function(e){
    var e = e || window.event,
        tar = e.target || e.srcElement;
        if(tar.nodeName.toLowerCase() === 'li'){
            tar.style.backgroundColor = 'gray';
        }
}
```

##数据访问对象模式
```
//使用localStorage
var BaseLocalStorage = function(preId, timeSign){
    this.preId = preId;
    this.timeSign = timeSign || '| - |';
}
BaseLocalStorage.prototype = {
    status:{
        SUCCESS : 0,
        FAILURE : 1,
        OVERFLOW : 2,
        TIMEOUT : 3
    },
    srotage : localStorage || window.localStorage,
    getKey :function(key){
        return this.preId + key;
    },
    set : function(key, value, callback, time){
        var status = this.status.SUCCESS,
            key = this.getKey(key);
        try{
            time = new Date(time).getTime() || time.getTime();
        }catch(e){
            time = new Date().getTime() + 1000*60*60*24*31;
        }

        try{
            this.storage.setItem(key, time +timeSign + value);
        }catch(e){
            status = this.status.OVERFLOW;
        }
        callback&&callback.call(this,status, key, value);
    },
    get : function(key, callback){
        var status = this.status.SUCCESS,
            key = this.getKey(key),
            value = null,
            timeSignLen = this.timeSign.length,
            that = this,
            index,
            time,
            result;
        try{
            value = this.storage.getItem(key);
        }catch(e){
            result = {
                status : this.status.FAILURE,
                value : null
            }
            callback&&callback.call(this,result.status,result.value);
            return result;
        }
        if(value){
            index = value.indexOf(this.timeSign);
            time = value.slice(0,index);
            if(new Date(time).getTime() > new Date().getTime() || time ==0){
                value = value.slice(index + timeSignLen);
            }else{
                value = null;
                status = that.status.TIMEOUT;
                that.remove(key);
            }
        }else{
            status = that.status.FAILURE;
        }
        result = {
            status : status,
            value : value
        }

        callback&&callback.call(this,result.status,result.value);
        return result;
    },
    remove: function(key, callback){
        var status = this.status.FAILURE,
            key = this.getKey(key),
            value = null;
        try{
            value = this.storage.getItem(key);
        }catch(e){ }
        if(value){
            try{
                this.storage.removeItem(key);
                status = this.status.SUCCESS;
            }catch(e){}
        }
        callback&&callback.call(this, status, status>0 ?null : value.slice(value.indexOf(this.timeSign)+this.timeSign.length));
    }
}
```

```
//nodeJS mongoDB封装
function connect(col, fn){
    mongodb.open(function(err,db){
            if(err){
                throw err;
            }

            db.collection(col,function(err,collection){
                if(err){
                    throw err;
                }
                fn&&fn(col,db);
            })
        })
}
var DB = function(col){
    return {
        insert: function(data, success, fail){
            connect(col, function(col, db){
                col.insert(data, function(err, docs){
                    if(err){
                        fail && fail();
                    }else{
                        success && success(docs);
                    }
                    db.close();
                })
            })
        },
        remove : function(data, success, fail){
            connect(col,function(col,db){
                col.remove(data,function(err, len){
                    if(err){
                        fail && fail();
                    }else{
                        success && success(len);
                    }
                    db.close();
                })
            })
        },
        update: function(con,doc,success,fail){
            connect(col,function(col,db){
                col.update(con,doc,function(err, len){
                    if(err){
                        fail && fail();
                    }else{
                        success && success();
                    }
                    db.close();
                })
            })
        },
        find : function(con,success,fail){
            connect(col,function(col,db){
                col.find(con).toArray(function(err, docs){
                    if(err){
                        fail && fail();
                    }else{
                        success && success(docs);
                    }
                    db.close();
                })
            })
        }
    }
}
```

## 节流模式

